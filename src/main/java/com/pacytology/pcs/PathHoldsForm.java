/*
    PathHoldsForm.java
    Software Engineer: Jon Cardella
*/

import java.awt.*;
import java.sql.*;
import javax.swing.*;
import java.util.Vector;
import Square;
import javax.swing.border.TitledBorder;

public class PathHoldsForm extends javax.swing.JFrame
{
    public PathHoldsRec[] pathHolds;
    public ResultCodeRec[] resultCodes;
    public int NUM_HOLDS = 0;
    public boolean START = true;
    boolean releaseStatus = false;
    boolean releaseMode = false;
    boolean releaseAll = false;
    boolean releaseFlag = false;
    boolean hasVerification = false;
    boolean firstRelease = false;
    final int CLEAR = -1;
    String dateToday;

	public PathHoldsForm()
	{

		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setTitle("Final Holds for Pathologist");
		setResizable(false);
		setDefaultCloseOperation(javax.swing.JFrame.DISPOSE_ON_CLOSE);
		getContentPane().setLayout(null);
		setSize(347,398);
		setVisible(false);
		pHoldPane.setOpaque(true);
		getContentPane().add(pHoldPane);
		pHoldPane.setBounds(20,104,232,282);
		pHoldPane.getViewport().add(pHoldList);
		pHoldList.setFont(new Font("DialogInput", Font.PLAIN, 12));
		pHoldList.setBounds(0,0,229,279);
		JLabel1.setText("Submitted");
		getContentPane().add(JLabel1);
		JLabel1.setBounds(22,88,62,12);
		JLabel2.setText("Path");
		getContentPane().add(JLabel2);
		JLabel2.setBounds(102,88,32,12);
		JLabel3.setText("Lab Number");
		getContentPane().add(JLabel3);
		JLabel3.setBounds(142,88,72,12);
		getContentPane().add(msgLabel);
		msgLabel.setForeground(java.awt.Color.red);
		msgLabel.setFont(new Font("Dialog", Font.BOLD, 12));
		msgLabel.setBounds(16,64,244,14);
		resultPane.setOpaque(true);
		getContentPane().add(resultPane);
		resultPane.setBounds(260,230,50,156);
		resultList.setEnabled(false);
		resultPane.getViewport().add(resultList);
		resultList.setFont(new Font("DialogInput", Font.PLAIN, 12));
		resultList.setBounds(0,0,47,153);
		getContentPane().add(verifiedOn);
		verifiedOn.setFont(new Font("DialogInput", Font.PLAIN, 12));
		verifiedOn.setBounds(260,114,76,20);
		getContentPane().add(verifiedBy);
		verifiedBy.setFont(new Font("DialogInput", Font.PLAIN, 12));
		verifiedBy.setBounds(260,150,76,20);
		resultCode.setEnabled(false);
		getContentPane().add(resultCode);
		resultCode.setFont(new Font("DialogInput", Font.PLAIN, 12));
		resultCode.setBounds(260,204,47,20);
		JLabel4.setText("Codes");
		getContentPane().add(JLabel4);
		JLabel4.setBounds(262,188,42,12);
		verifyDateLbl.setText("Date Verified:");
		getContentPane().add(verifyDateLbl);
		verifyDateLbl.setBounds(260,100,80,12);
		verifiedLbl.setText("Verified By:");
		getContentPane().add(verifiedLbl);
		verifiedLbl.setBounds(260,134,100,16);
		titledBorder1.setTitle("VERIFICATION");
		//$$ titledBorder1.move(0,576);
		getContentPane().add(F1sq);
		F1sq.setBounds(25,6,20,20);
		F1lbl.setRequestFocusEnabled(false);
		F1lbl.setText("F2");
		getContentPane().add(F1lbl);
		F1lbl.setForeground(java.awt.Color.black);
		F1lbl.setFont(new Font("SansSerif", Font.PLAIN, 10));
		F1lbl.setBounds(29,6,20,20);
		getContentPane().add(F2sq);
		F2sq.setBounds(77,6,20,20);
		F2lbl.setRequestFocusEnabled(false);
		F2lbl.setText("F9");
		getContentPane().add(F2lbl);
		F2lbl.setForeground(java.awt.Color.black);
		F2lbl.setFont(new Font("SansSerif", Font.PLAIN, 10));
		F2lbl.setBounds(81,6,20,20);
		getContentPane().add(F3sq);
		F3sq.setBounds(129,6,20,20);
		F3lbl.setRequestFocusEnabled(false);
		F3lbl.setText("F12");
		getContentPane().add(F3lbl);
		F3lbl.setForeground(java.awt.Color.black);
		F3lbl.setFont(new Font("SansSerif", Font.PLAIN, 10));
		F3lbl.setBounds(130,6,20,20);
		F2action.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
		F2action.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		F2action.setText("Exit");
		getContentPane().add(F2action);
		F2action.setForeground(java.awt.Color.black);
		F2action.setBounds(62,30,50,16);
		F3action.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
		F3action.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		F3action.setText("Submit");
		getContentPane().add(F3action);
		F3action.setForeground(java.awt.Color.black);
		F3action.setBounds(114,30,50,16);
		F1action.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
		F1action.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		F1action.setText("Release");
		getContentPane().add(F1action);
		F1action.setForeground(java.awt.Color.black);
		F1action.setBounds(10,30,50,16);
		//$$ JOptionPane1.move(0,344);
		//}}

		//{{INIT_MENUS
		//}}
	
		//{{REGISTER_LISTENERS
		SymKey aSymKey = new SymKey();
		this.addKeyListener(aSymKey);
		resultCode.addKeyListener(aSymKey);
		verifiedOn.addKeyListener(aSymKey);
		verifiedBy.addKeyListener(aSymKey);
		//}}
	}

	public PathHoldsForm(String sTitle)
	{
		this();
		setTitle(sTitle);
	}
	
    /*
        This usage discontinued; removed use of method specific dbProc
        and using dbConnection one instead
    */
	public PathHoldsForm(ResultCodeRec[] resultCodes, Connection dbProc) {
	    this();
	    //this.dbProc=dbProc;
	    this.resultCodes=resultCodes;
        this.setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));
	    this.START=this.queryPathHolds();
        this.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
	    if (START) {
	        this.refreshHoldList();
	        this.displayResultCodes(0);
            this.pHoldList.setSelectedIndex(0);
            this.resetColors();
            this.repaint();
        }
        else Utils.createErrMsg("No data available - make sure drafts are printed");            
	}
	
	public PathHoldsForm(ResultCodeRec[] resultCodes) {
	    this();
	    this.resultCodes=resultCodes;
        this.setCursor(new java.awt.Cursor(java.awt.Cursor.WAIT_CURSOR));
	    this.START=this.queryPathHolds();
        this.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
	    if (START) {
	        this.refreshHoldList();
	        this.displayResultCodes(0);
            this.pHoldList.setSelectedIndex(0);
            this.resetColors();
            this.repaint();
        }
        else Utils.createErrMsg("No data available - make sure drafts are printed");            
	}

	public void setVisible(boolean b)
	{
		if (b) setLocation(80,80);
		super.setVisible(b);
		if (!this.START) this.dispose();
		//else this.resultCode.requestFocus();
		//else this.verifiedOn.requestFocus();
		else enableVerified();
	}

	static public void main(String args[])
	{
		(new PathHoldsForm()).setVisible(true);
	}

	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets and menu bar
		Insets insets = getInsets();
		javax.swing.JMenuBar menuBar = getRootPane().getJMenuBar();
		int menuBarHeight = 0;
		if (menuBar != null)
			menuBarHeight = menuBar.getPreferredSize().height;
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height + menuBarHeight);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	javax.swing.JScrollPane pHoldPane = new javax.swing.JScrollPane();
	javax.swing.JList pHoldList = new javax.swing.JList();
	javax.swing.JLabel JLabel1 = new javax.swing.JLabel();
	javax.swing.JLabel JLabel2 = new javax.swing.JLabel();
	javax.swing.JLabel JLabel3 = new javax.swing.JLabel();
	javax.swing.JLabel msgLabel = new javax.swing.JLabel();
	javax.swing.JScrollPane resultPane = new javax.swing.JScrollPane();
	javax.swing.JList resultList = new javax.swing.JList();
	javax.swing.JTextField verifiedOn = new javax.swing.JTextField();
	javax.swing.JTextField verifiedBy = new javax.swing.JTextField();
	javax.swing.JTextField resultCode = new javax.swing.JTextField();
	javax.swing.JLabel JLabel4 = new javax.swing.JLabel();
	javax.swing.JLabel verifyDateLbl = new javax.swing.JLabel();
	javax.swing.JLabel verifiedLbl = new javax.swing.JLabel();
	javax.swing.border.TitledBorder titledBorder1 = new javax.swing.border.TitledBorder();
	Square F1sq = new Square();
	javax.swing.JLabel F1lbl = new javax.swing.JLabel();
	Square F2sq = new Square();
	javax.swing.JLabel F2lbl = new javax.swing.JLabel();
	Square F3sq = new Square();
	javax.swing.JLabel F3lbl = new javax.swing.JLabel();
	javax.swing.JLabel F2action = new javax.swing.JLabel();
	javax.swing.JLabel F3action = new javax.swing.JLabel();
	javax.swing.JLabel F1action = new javax.swing.JLabel();
	//}}

	//{{DECLARE_MENUS
	//}}


	class SymKey extends java.awt.event.KeyAdapter
	{
		public void keyTyped(java.awt.event.KeyEvent event)
		{
			Object object = event.getSource();
			if (object == resultCode)
				resultCode_keyTyped(event);
			else if (object == verifiedOn)
				verifiedOn_keyTyped(event);
			else if (object == verifiedBy)
				verifiedBy_keyTyped(event);
		}

		public void keyPressed(java.awt.event.KeyEvent event)
		{
			Object object = event.getSource();
			if (object == PathHoldsForm.this)
				PathHoldsForm_keyPressed(event);
			if (object == resultCode)
				resultCode_keyPressed(event);
			else if (object == verifiedOn)
				verifiedOn_keyPressed(event);
			else if (object == verifiedBy)
				verifiedBy_keyPressed(event);
		}
	}
	
	void increment()
	{
        int ndx = pHoldList.getSelectedIndex();
        if (ndx<0) ndx=0;
        else ndx++;
        if (ndx>=NUM_HOLDS) ndx=NUM_HOLDS-1;
        if (!releaseMode) {
            pHoldList.setSelectedIndex(ndx);
            pHoldList.ensureIndexIsVisible(ndx);
        }
        displayResultCodes(ndx);
	}

	void PathHoldsForm_keyPressed(java.awt.event.KeyEvent event)
	{
		int key = event.getKeyCode();
		int ndx = 0;
		boolean canProceed = true;
		switch (key) {
		    case event.VK_F9:
		        this.dispose();
		        break;
            case event.VK_F2:
                if (!firstRelease && !hasVerification) {
                    firstRelease=true;
                    if (!confirmVerified()) {
                        verifiedOn.requestFocus();
                        canProceed=false;
                    }
                }
                if (canProceed) {
                if (NUM_HOLDS>0) { 
                    ndx=pHoldList.getSelectedIndex();
                    if (ndx>=0) {
                        if (!pathHolds[ndx].resultsChanged) {
                            releaseMode=true;
                            releaseHold();
                            if (!Utils.isNull(pathHolds[ndx].released)) {
                                resultCode.setEnabled(false);
                                msgLabel.requestFocus();
                            }
                        }
                        else Utils.createErrMsg(
                            "Cannot release because result codes where changed");
                        increment();
                    }
                }
                }
                break;
            case event.VK_F10:
                boolean verifyStatus = confirmVerified();
                if (verifyStatus) disableVerified();
                else enableVerified();
                break;
            case event.VK_DOWN:
                /*
                ndx = pHoldList.getSelectedIndex();
                if (ndx<0) ndx=0;
                else ndx++;
                if (ndx>=NUM_HOLDS) ndx=NUM_HOLDS-1;
                if (!releaseMode) {
                    pHoldList.setSelectedIndex(ndx);
                    pHoldList.ensureIndexIsVisible(ndx);
                }
                displayResultCodes(ndx);
                */
                increment();
                break;
            case java.awt.event.KeyEvent.VK_F12:
                if (NUM_HOLDS>0) {
                    this.setCursor(new java.awt.Cursor(
                        java.awt.Cursor.WAIT_CURSOR));
                    updatePathHolds();
                    queryPathHolds();
                    this.setCursor(new java.awt.Cursor(
                        java.awt.Cursor.DEFAULT_CURSOR));
                    refreshHoldList();
                    if (NUM_HOLDS>0) { 
	                    displayResultCodes(0);
                        pHoldList.setSelectedIndex(0);
                        resultCode.requestFocus();
                    }
                }
                break;
            case event.VK_F8:
                if (resultCode.hasFocus()) {
                    String buf[] = new String [resultCodes.length];
		            String buf2[] = new String [resultCodes.length];
		            for (int i=0;i<resultCodes.length;i++) {
		                buf[i]=
		                    resultCodes[i].bethesda_code+"   "+
		                    resultCodes[i].description;
                            buf2[i]=resultCodes[i].bethesda_code;
                    }
                    (new PickList("Result Codes",
                        200,40,320,360,
                        resultCodes.length,buf,buf2,
                        resultCode)).setVisible(true);
                }
                break;
            case java.awt.event.KeyEvent.VK_ESCAPE:
                if (NUM_HOLDS>0) {
                    for (int i=0;i<NUM_HOLDS;i++) {
                        pathHolds[i].released=null;
                    }
                    this.setCursor(new java.awt.Cursor(
                        java.awt.Cursor.WAIT_CURSOR));
                    queryPathHolds();
                    this.setCursor(new java.awt.Cursor(
                        java.awt.Cursor.DEFAULT_CURSOR));
                    refreshHoldList();
	                displayResultCodes(0);
                    pHoldList.setSelectedIndex(0);
                    //resultCode.requestFocus();
                    hasVerification=false;
                    firstRelease=false;
                    enableVerified();
                }
                break;
            case event.VK_UP:
                ndx = pHoldList.getSelectedIndex();
                if (ndx>0) ndx--;
                else ndx=0;
                if (!releaseMode) {
                    pHoldList.setSelectedIndex(ndx);
                    pHoldList.ensureIndexIsVisible(ndx);
                }
                displayResultCodes(ndx);
                break;
            case event.VK_CONTROL:
                resultCode.setText(null);
                break;
		}
	}
	
	public void displayResultCodes(int ndx)
	{
        resultList.removeAll();
	    if (ndx==CLEAR) {
	        Vector v = new Vector();
	        resultList.setListData(v);
	        resultCode.setEnabled(false);
	        msgLabel.requestFocus();
	    }
	    else {
	        resultList.setListData(pathHolds[ndx].resultVect);
	        if (Utils.isNull(pathHolds[ndx].released)) {
	            resultCode.setEnabled(true);
	            resultCode.requestFocus();
	        }
	        else {
	            resultCode.setEnabled(false);
	            msgLabel.requestFocus();
	        }
	    }
        resultList.repaint();
	    resultList.revalidate();
	    resultCode.setText(null);
	}
	
    // this functionality has been disabled
	public void releaseAllHolds()
	{
	    releaseFlag=true;
	    setReleaseStatus();
	}
	
	public void releaseHold() {
	    int ndx=pHoldList.getSelectedIndex();
	    if (!Utils.isNull(pathHolds[ndx].released)) {
	        releaseStatus=false;
	    }
	    else {
	        releaseStatus=true;
        }
        setReleaseStatus();
	}
	
	public void refreshHoldList() {
        Vector holdList = new Vector();
        pHoldList.removeAll();
	    if (NUM_HOLDS>0) {
	        for (int i=0;i<NUM_HOLDS;i++) {
	            String buf=pathHolds[i].submitted+"  "+
	                pathHolds[i].pathologist_code+"  "+
	                pathHolds[i].lab_number;
	            if (!Utils.isNull(pathHolds[i].released))
	                buf=buf+" R";
	            holdList.addElement(buf);
	        }
	        pHoldList.setListData(holdList);
	        int ndx = pHoldList.getSelectedIndex();
	        pHoldList.ensureIndexIsVisible(ndx);
	    }
	    else {
	        holdList.addElement("NO DATA AVAILABLE");
	        pHoldList.setListData(holdList);
	        pHoldList.setSelectedIndex(-1);
	        displayResultCodes(CLEAR);
	    }
	    pHoldList.revalidate();
	    pHoldList.repaint();
	}
	
    public boolean updatePathHolds()  {
        boolean exitStatus=true;
        Statement stmt = null;
        PreparedStatement pstmt = null;
        try  {
            String updQuery = 
                "UPDATE pcs.pathologist_holds \n"+
                "SET released=SysDate, \n"+
                "    verified_on=TO_DATE(?,'MMDDYYYY'), \n"+
                "    verified_by=?"+
                "WHERE lab_number=";
                
            String addQuery = 
                "INSERT INTO pcs.cytopath_print_queue \n"+
                "VALUES (";

            stmt = dbConnection.process().createStatement();
            for (int i=0;i<NUM_HOLDS;i++) {
                if (!Utils.isNull(pathHolds[i].released)) {
                    String buf = updQuery+
                        pathHolds[i].lab_number+" \n";
                    String vPath = null;
                    String vDate = null;
                    if (hasVerification) {
                        if (!pathHolds[i].pathologist_code.equals(verifiedBy.getText())) {
                            vDate=Utils.stripDateMask(verifiedOn.getText());
                            vPath=verifiedBy.getText();
                        }
                    }
                    pstmt=dbConnection.process().prepareStatement(buf);
                    pstmt.setString(1,vDate);
                    pstmt.setString(2,vPath);
                    int rs = pstmt.executeUpdate(buf);
                    buf = addQuery+
                        pathHolds[i].lab_number+",2) \n";
                    rs = stmt.executeUpdate(buf);
                }
                if (pathHolds[i].resultsChanged) {
                    String buf = addQuery+
                        pathHolds[i].lab_number+",1) \n";
                    int rs = stmt.executeUpdate(buf);
                        String subQuery = null;
                        if (pathHolds[i].pc_status.equals("Y")) {
                            subQuery = 
                                "DELETE FROM pcs.pathologist_control_codes \n"+
                                "WHERE lab_number="+pathHolds[i].lab_number+" \n";
                            stmt.executeUpdate(subQuery);
                            for (int j=0; j<pathHolds[i].resultVect.size(); j++) {
                                subQuery = 
                                    "INSERT INTO pcs.pathologist_control_codes \n"+
                                    "VALUES ("+pathHolds[i].lab_number+",'"+
                                    (String)pathHolds[i].resultVect.elementAt(j)+"','"+
                                    (String)pathHolds[i].resultVect.elementAt(j)+"') \n";
                                stmt.executeUpdate(subQuery);                                    
                            }
                        }
                        else if (pathHolds[i].qc_status.equals("Y")) {
                            subQuery = 
                                "DELETE FROM pcs.quality_control_codes \n"+
                                "WHERE lab_number="+pathHolds[i].lab_number+" \n";
                            stmt.executeUpdate(subQuery);
                            for (int j=0; j<pathHolds[i].resultVect.size(); j++) {
                                subQuery = 
                                    "INSERT INTO pcs.quality_control_codes \n"+
                                    "VALUES ("+pathHolds[i].qc_id+","+
                                    pathHolds[i].lab_number+",'"+
                                    (String)pathHolds[i].resultVect.elementAt(j)+"','"+
                                    (String)pathHolds[i].resultVect.elementAt(j)+"') \n";
                                stmt.executeUpdate(subQuery);                                    
                            }
                        }
                        else {
                            subQuery = 
                                "DELETE FROM pcs.lab_result_codes \n"+
                                "WHERE lab_number="+pathHolds[i].lab_number+" \n";
                            stmt.executeUpdate(subQuery);
                            for (int j=0; j<pathHolds[i].resultVect.size(); j++) {
                                subQuery = 
                                    "INSERT INTO pcs.lab_result_codes \n"+
                                    "VALUES ("+pathHolds[i].lab_number+",'"+
                                    (String)pathHolds[i].resultVect.elementAt(j)+"') \n";
                                stmt.executeUpdate(subQuery);                                    
                            }
                        }
                }
            }
            try { stmt.close(); }
            catch (SQLException e) { 
                System.out.println(e.toString());
                exitStatus=false; 
            }                
        }
        catch (Exception e) {
            System.out.println(e+" updatePathHolds");
            exitStatus=false;
            msgLabel.setText("Operation Failed");
        }
        return(exitStatus);            
    }

   public boolean queryPathHolds()  {
        boolean exitStatus=true;
        Statement stmt = null;
        ResultSet rs1 = null;
        ResultSet rs2 = null;
        try  {
            String query = 
                "SELECT ph.pathologist_code,ph.lab_number, \n"+
                "   TO_CHAR(ph.submitted,'MM/DD/YYYY'),r.qc_status, \n"+
                "   r.path_status, TO_CHAR(SysDate,'MMDDYYYY') \n"+
                "FROM pcs.pathologist_holds ph, pcs.lab_results r, \n"+
                "   pcs.cytopath_print_queue q \n"+
                "WHERE ph.released IS NULL and ph.lab_number=r.lab_number and \n"+
                "   ph.lab_number=q.lab_number(+) and q.lab_number IS NULL \n"+
                "ORDER BY ph.lab_number \n";
                
            stmt = dbConnection.process().createStatement();
            rs1 = stmt.executeQuery(query);
            NUM_HOLDS=0;
            while (rs1.next()) { NUM_HOLDS++; }
            if (NUM_HOLDS>0) {
                pathHolds = new PathHoldsRec[NUM_HOLDS];
                rs1=stmt.executeQuery(query);
                int ndx=0;
                while (rs1.next()) {
                    pathHolds[ndx] = new PathHoldsRec();
                    pathHolds[ndx].pathologist_code=rs1.getString(1);
                    pathHolds[ndx].lab_number=rs1.getInt(2);
                    pathHolds[ndx].submitted=rs1.getString(3);
                    pathHolds[ndx].qc_status=rs1.getString(4);
                    pathHolds[ndx].pc_status=rs1.getString(5);
                    dateToday=rs1.getString(6);
                    ndx++;
                }
                for (ndx=0; ndx<NUM_HOLDS; ndx++) {
                    String subQuery = null;
                    if (pathHolds[ndx].pc_status.equals("Y"))
                        subQuery =
                            "SELECT bethesda_code,null \n"+
                            "FROM pcs.pathologist_control_codes \n"+
                            "WHERE lab_number="+pathHolds[ndx].lab_number+" \n";
                    else if (pathHolds[ndx].qc_status.equals("Y"))
                        subQuery =
                            "SELECT bethesda_code,qc_id \n"+
                            "FROM pcs.quality_control_codes \n"+
                            "WHERE lab_number="+pathHolds[ndx].lab_number+" \n";
                    else
                        subQuery =
                            "SELECT bethesda_code,null \n"+
                            "FROM pcs.lab_result_codes \n"+
                            "WHERE lab_number="+pathHolds[ndx].lab_number+" \n";
                    rs2=stmt.executeQuery(subQuery);
                    pathHolds[ndx].resultVect = new Vector();
                    while (rs2.next()) {
                        pathHolds[ndx].resultVect.addElement(rs2.getString(1));
                        pathHolds[ndx].qc_id=rs2.getInt(2);
                    }
                }
            }
            else { exitStatus=false; }
            try { stmt.close(); }
            catch (SQLException e) { 
                System.out.println(e.toString());
                exitStatus=false; 
            }             
        }
        catch (Exception e) {
            System.out.println(e+" queryPathHolds");
            exitStatus=false;
        }
        return(exitStatus);            
    }


    void setReleaseStatus()
	{
	    if (releaseFlag) {
	        if (releaseAll) {
	            releaseAll=false;
	            for (int i=0; i<NUM_HOLDS; i++) {
	                pHoldList.setSelectedIndex(i);
	                pathHolds[i].released=null;
	                refreshHoldList();
	            }
	        }
	        else {
	            releaseAll=true;
	            for (int i=0; i<NUM_HOLDS; i++) {
	                pHoldList.setSelectedIndex(i);
	                pathHolds[i].released=dateToday;
	                refreshHoldList();
	            }
	        }
	        releaseFlag=false;
	        pHoldList.setSelectedIndex(0);
	        displayResultCodes(0);
            resultCode.requestFocus();
	    }
	    else {
	        int ndx = pHoldList.getSelectedIndex();    
            if (!releaseStatus) pathHolds[ndx].released=null;
            else pathHolds[ndx].released=dateToday;
            refreshHoldList();
            pHoldList.setSelectedIndex(ndx);
	        displayResultCodes(ndx);
            resultCode.requestFocus();
        }
        releaseMode=false;
        releaseStatus=false;
        msgLabel.setText(null);
	}
	

	void resultCode_keyTyped(java.awt.event.KeyEvent event)
	{
		Utils.forceUpper(event,3);
	}

	void resultCode_keyPressed(java.awt.event.KeyEvent event)
	{
		int key = event.getKeyCode();
		int ndx = pHoldList.getSelectedIndex();
		if (key==event.VK_ENTER) {
		    String code = resultCode.getText();
		    if (resultCodeExists(code)) {
		        pathHolds[ndx].resultsChanged=true;
		        if (!pathHolds[ndx].resultVect.contains(code)) {
		            pathHolds[ndx].resultVect.addElement(code);
		            displayResultCodes(ndx);
		        }
		    }
		}
		else if (key==event.VK_DELETE) {
		    String code = resultCode.getText();
		    if (resultCodeExists(code)) {
		        pathHolds[ndx].resultsChanged=true;
		        if (pathHolds[ndx].resultVect.contains(code)) {
		            pathHolds[ndx].resultVect.removeElement(code);
		            displayResultCodes(ndx);
		        }
		    }
		}
	}
	
	public boolean resultCodeExists(String code) {
	    boolean rv = false;
	    for (int i=0;i<resultCodes.length;i++) {
	        if (resultCodes[i].bethesda_code.equals(code)) {
	            rv=true;
	            break;
	        }
	    }
	    if (!rv) {
	        String msg="Result Code "+code+" does not exist";
	        Utils.createErrMsg(msg);
	    }
	    return (rv);
	}
	
	void resetColors()
	{
	    Utils.setColors(this.getContentPane());
	    this.getContentPane().setBackground((Color.red).darker());
	    msgLabel.setForeground(Color.green);
	    resultList.setFont(new Font("DialogInput", Font.PLAIN, 12));
	    pHoldList.setFont(new Font("DialogInput", Font.PLAIN, 12));
	}

	void verifiedOn_keyPressed(java.awt.event.KeyEvent event)
	{
		if (event.getKeyCode()==event.VK_ENTER) {
		    if (Utils.isNull(verifiedOn.getText())) {
		        boolean verifyStatus = confirmVerified();
		        if (verifyStatus) disableVerified();
		        else enableVerified();
		    }
		    else {
		        if (Utils.dateVerify(verifiedOn)) {
		            verifiedOn.transferFocus();
		            verifiedOn.setEnabled(false);
		        }
		    }
		}
	}

	void verifiedOn_keyTyped(java.awt.event.KeyEvent event)
	{
		Utils.buildDateMask(event);
	}

	void verifiedBy_keyPressed(java.awt.event.KeyEvent event)
	{
		if (event.getKeyCode()==event.VK_ENTER) {
		    if (Utils.required(verifiedBy,"Verified By")) {
		        if (pathExists(verifiedBy.getText())) {
		            if (confirmVerified()) {
		                verifiedOn.setEnabled(false);
		                verifiedBy.setEnabled(false);
		                verifiedBy.transferFocus();
                    }
                    else enableVerified();
		        }
		        else {
		            Utils.createErrMsg(
		                "Pathologist "+verifiedBy.getText()+" does not exist!");
		            verifiedBy.setText(null);
		        }
		    }
		}
	}

	void verifiedBy_keyTyped(java.awt.event.KeyEvent event)
	{
		Utils.forceUpper(event,3);
	}
	
	void disableVerified()
	{
	    hasVerification=false;
	    verifiedBy.setEnabled(false);
	    verifiedOn.transferFocus();
	    verifiedOn.setEnabled(false);
	}
	
	void enableVerified()
	{
	    hasVerification=false;
        verifiedBy.setText(null);
        verifiedBy.setEnabled(true);
        verifiedOn.setText(null);
        verifiedOn.setEnabled(true);
        verifiedOn.requestFocus();
	}
	
    boolean confirmVerified()
    {
        String on = verifiedOn.getText();
        String by = verifiedBy.getText();
        String msg = null;
        boolean verifyStatus = false;
	    JOptionPane verify = new javax.swing.JOptionPane();
        // no verification selected
        if (!Utils.isNull(on)&&!Utils.isNull(by)) {
            msg="This batch of holds VERIFIED!\nDate: "+on+"    By: "+by+"\nIs this information CORRECT?";
            hasVerification=true;
        }
        else {
            msg="No verification for these holds!\nIs this CORRECT?";
        }
	    Object[] options = {"YES","NO"};
        int rv = verify.showOptionDialog(
		            null,msg,
		            "Confirm Verification",verify.DEFAULT_OPTION,
		            verify.QUESTION_MESSAGE,null,options,options[1]);
        if (rv==verify.YES_OPTION) {
            verifyStatus=true;
        }
        else hasVerification=false;
        return(verifyStatus);
    }

	boolean pathExists(String p)
	{
        boolean exitStatus=true;
        int rowsReturned=0;
        try  {
            String SQL = new String(
                    "SELECT count(*) \n"+
                    "FROM pcs.pathologists \n"+
                    "WHERE pathologist_code='"+p+"' \n"+
                    "AND active_status='A' \n");
            Statement stmt = dbConnection.process().createStatement();
            ResultSet rs = stmt.executeQuery(SQL);
            while (rs.next()) { rowsReturned=rs.getInt(1); }
            try { rs.close(); stmt.close(); }
            catch (SQLException e) { 
                System.out.println("ERROR: Closing statement \n"+e);
                exitStatus=false; 
            }                
        }
        catch (Exception e) {
            System.out.println(e+" query");
            exitStatus=false;
        }
        if (rowsReturned==0) exitStatus=false;
        return(exitStatus);            
	}
	
}
